
{#-#############################################}
{#-################ Struct body ################}
{#-#############################################}
pub struct {{ m.bumpalo_ident }}<'bump> {
    _bump: &'bump ::puroro::bumpalo::Bump,
    _bitfield: ::puroro::bitvec::array::BitArray<
        ::puroro::bitvec::order::Lsb0,
        [u32; ({{ m.bitfield_len }} + 31) / 32],
    >,

    {%- for field in m.fields %}
    {%- if !field.is_explicit_oneof_field %}
    {{ field.ident }}: {{ field.bumpalo_field_type }},
    {%- endif %}
    {%- endfor %}

    {%- for oneof in m.oneofs %}
    {{ oneof.field_ident }}: 
        super::_puroro_nested::{{ m.submodule_ident }}::_puroro_private_oneofs::{{ oneof.bumpalo_enum_ident }}<'bump>,
    {%- endfor %}
}

pub type {{ m.bumpalo_owned_ident }} = ::puroro::BumpaloOwned<{{ m.bumpalo_ident }}<'static>>;


{#-################################################}
{#-################ Struct methods ################}
{#-################################################}
impl<'bump> {{ m.bumpalo_ident }}<'bump> {

    {#- ######## new_in ######## #}
    pub fn new_in(bump: &'bump ::puroro::bumpalo::Bump) -> Self {
        {#- We need to make this `bump_ref` to cut off the borrow from the param `bump`
         #  so that we can move the `bump` into our struct.
         #}
        #[allow(unused)]
        let bump_ref: &::puroro::bumpalo::Bump = unsafe {
            ::std::mem::transmute(
                ::std::ops::Deref::deref(&bump)
            )
        };

        Self {
            _bump: bump,
            _bitfield: ::std::default::Default::default(),

            {%- for field in m.fields %}
            {%- if !field.is_explicit_oneof_field %}
            {%- if field.is_repeated %}
            {{ field.ident }}: ::puroro::internal::NoAllocBumpVec::new_in(bump),
            {%- else %}
            {%- if field.is_length_delimited %}
            {%- if field.is_message %}
            {{ field.ident }}: ::std::option::Option::None,
            {%- endif %} {#- if field.is_message #}
            {%- if field.is_string %}
            {{ field.ident }}: ::puroro::internal::NoAllocBumpString::new_in(bump),
            {%- endif %} {#- if field.is_string #}
            {%- if field.is_bytes %}
            {{ field.ident }}: ::puroro::internal::NoAllocBumpVec::new_in(bump),
            {%- endif %} {#- if field.is_bytes #}
            {%- else %} {#- if field.is_length_delimited #}
            {{ field.ident }}: ::std::default::Default::default(),
            {%- endif %} {#- if field.is_length_delimited #}
            {%- endif %} {#- if field.is_repeated #}
            {%- endif %} {#- if !field.is_explicit_oneof_field #}
            {%- endfor %} {#- for field in m.fields #}

            {%- for oneof in m.oneofs %}
            {{ oneof.field_ident }}: ::std::default::Default::default(),
            {%- endfor %}
        }
    }

    {#- ######## getter ######## #}
    {%- for field in m.fields %}
    {%- if !field.is_explicit_oneof_field %}
    {%- if field.is_repeated %}
    
    {#- ######## repeated getter ######## #}
    pub fn {{ field.ident }}<'this>(&'this self) -> {{ field.bumpalo_getter_type }} {
        {%- if field.is_message %}
        unsafe { self.{{ field.ident }}.cast_item_unchecked() }
        {%- else %} {#- if field.is_message #}
        &self.{{ field.ident }}
        {%- endif %} {#- if field.is_message #}
    }

    {%- else %} {#- if field.is_repeated #}

    {#- ######## non-repeated getter ######## #}

    {#- optional getter #}
    pub fn {{ field.ident_unesc }}_opt<'this>(&'this self) -> {{ field.bumpalo_getter_opt_type }} {
        {%- if field.is_message %}
        {#- Non-repeated message field. Field type is always `Optional<NoAllocBox<T>>`.#}
        {#- Need to cast the lifetime. #}
        self.{{ field.ident }}.as_ref().map(|x| unsafe { ::std::mem::transmute(::std::ops::Deref::deref(x)) })

        {%- else %} {#- if field.is_message #}
        {%- if field.has_optional_bit %}
        {#- Non-repeated, non-message, optional field. Optional bit is stored in the bitfield. #}
        if self._bitfield.get({{ field.bitfield_index }}).map_or(false, |v| *v) {
            ::std::option::Option::Some(
                {%- if field.is_length_delimited %}
                &self.{{ field.ident }}
                {%- else %} {#- if field.is_length_delimited #}
                self.{{ field.ident }}
                {%- endif %} {#- if field.is_length_delimited #}
            )
        } else {
            ::std::option::Option::None
        }
        {%- else %} {#- if field.has_optional_bit #}
        {#- Non-repeated, non-message, unlabeled field. Treat as unexisting when it's default value. #}
        if !::puroro::internal::IsDefault::is_default(&self.{{ field.ident }}) {
            ::std::option::Option::Some(
                {%- if field.is_length_delimited %}
                &self.{{ field.ident }}
                {%- else %} {#- if field.is_length_delimited #}
                self.{{ field.ident }}
                {%- endif %} {#- if field.is_length_delimited #}
            )
        } else {
            ::std::option::Option::None
        }
        {%- endif %} {#- if field.has_optional_bit #}
        {%- endif %} {#- if field.is_message #}
    }

    {#- normal getter, has_ getter #}
    pub fn {{ field.ident }}<'this>(&'this self) -> {{ field.bumpalo_getter_type }} {
        {%- if field.is_message %}
        {#- For message, we return `Option` value even in normal getter method. #}
        self.{{ field.ident_unesc }}_opt()
        {%- else %} {#- if field.is_message #}
        match self.{{ field.ident_unesc }}_opt() {
            ::std::option::Option::Some(x) => x,
            _ => {
                {%- if field.has_default_value %}
                {{ field.default_value }}
                {%- else %} {#- if field.has_default_value #}
                ::std::default::Default::default()
                {%- endif %} {#- if field.has_default_value #}
            }
        }
        {%- endif %} {#- if field.is_message #}
    }
    pub fn has_{{ field.ident_unesc }}(&self) -> bool {
        self.{{ field.ident_unesc }}_opt().is_some()
    }

    {%- endif %} {#- if field.is_repeated #}
    {%- endif %} {#- if !field.is_explicit_oneof_field #}
    {%- endfor %} {#- for field in m.fields #}

    {#- ######## mut getter ######## #}

    {%- for field in m.fields %}
    {%- if !field.is_explicit_oneof_field %}

    {%- if field.is_repeated %}

    {#- mut get repeated field #}
    pub fn {{ field.ident_unesc }}_mut<'this>(&'this mut self) -> {{ field.bumpalo_getter_mut_type }} {
        todo!()
    }
    {#- TODO!! What should I do for e.g. repeated bytes field? #}

    {%- else %} {#- if field.is_repeated #}

    {#- clear scalar field #}
    pub fn clear_{{ field.ident_unesc }}(&mut self) {
        {%- if field.has_optional_bit %}
        self._bitfield.set({{ field.bitfield_index }}, false);
        {#- Skip dropping the field. No need to do that unless it's a message field, #}
        {#- and the message field will never have optional bitfield. #}
        {%- else %} {#- if field.has_optional_bit #}
        self.{{ field.ident }} = ::std::default::Default::default();
        {%- endif %} {#- if field.has_optional_bit #}
    }

    {#- mut get scalar field #}
    {#- always returns an option-unwrapped mut reference. The value is initialized if it's not present. #}
    pub fn {{ field.ident_unesc }}_mut<'this>(&'this mut self) -> {{ field.bumpalo_getter_mut_type }} {
        if !self.has_{{ field.ident_unesc }}() {
            {#- field is not set so we need to initialize it. #}
            self.{{ field.ident }} = ::std::default::Default::default();

            {%- if field.has_optional_bit %}
            self._bitfield.set({{ field.bitfield_index }}, true);
            {%- endif %} {#- if field.has_optional_bit #}
        }
        
        {%- if field.is_length_delimited %}
        {%- if field.is_message %}
        {#- Non-repeated message field. Field type is always `Optional<NoAllocBox<T>>`.#}
        let bump = self._bump;
        self.{{ field.ident }}.get_or_insert_with(|| ::puroro::internal::NoAllocBumpBox::new_in(
            ::puroro::internal::BumpDefault::default_in(bump),
            bump,
        ))
        {%- endif %} {#- if field.is_message #}
        {%- if field.is_string %}
        unsafe { self.{{ field.ident }}.as_mut_string_in(self._bump) } 
        {%- endif %} {#- if field.is_string #}
        {%- if field.is_bytes %}
        unsafe { self.{{ field.ident }}.as_mut_vec_in(self._bump) }
        {%- endif %} {#- if field.is_bytes #}
        {%- else %} {#- if field.is_length_delimited #}
        &mut self.{{ field.ident }}
        {%- endif %} {#- if field.is_length_delimited #}
    }

    {%- endif %} {#- if field.is_repeated #}
    {%- endif %} {#- if !field.is_explicit_oneof_field #}
    {%- endfor %} {#- for field in m.fields #}
}


{#-####################################################}
{#-################ puroro trait impls ################}
{#-####################################################}
impl<'bump> ::puroro::Message<super::_puroro_simple_impl::{{ m.simple_ident }}> for {{ m.bumpalo_ident }}<'bump> {}

impl<'bump> ::puroro::BumpaloMessage<'bump> for {{ m.bumpalo_ident }}<'bump> {
    fn new_in(bump: &'bump ::puroro::bumpalo::Bump) -> Self {
        Self::new_in(bump)
    }
}

impl<'bump> ::puroro::internal::BumpDefault<'bump> for {{ m.bumpalo_ident }}<'bump> {
    fn default_in(bump: &'bump ::puroro::bumpalo::Bump) -> Self {
        Self::new_in(bump)
    }
}

impl<'bump> super::_puroro_traits::{{ m.trait_ident }} for {{ m.bumpalo_ident }}<'bump> {
    {%- for field in m.fields %}
    {%- call bumpalo_trait_impl_field(field) %}
    {%- endfor %}

    {%- for oneof in m.oneofs %}
    fn {{ oneof.field_ident }}<'this>(&'this self) ->
        Option<
            super::_puroro_nested::{{ m.submodule_ident }}::_puroro_oneofs::{{ oneof.enum_ident }}
            {%- if oneof.has_ld_field %}
            {%- if oneof.has_message_field %}
            <'this, Self>
            {%- else %}
            <'this>
            {%- endif %}
            {%- endif %}
        >
    {
        use super::_puroro_nested::{{ m.submodule_ident }}::_puroro_private_oneofs::{{ oneof.bumpalo_enum_ident }} as E;
        use super::_puroro_nested::{{ m.submodule_ident }}::_puroro_oneofs::{{ oneof.enum_ident }} as F;
        match &self.{{ oneof.field_ident }} {
            E::_None(_) => ::std::option::Option::None,
            {%- for field in oneof.fields %}
            E::{{ field.ident }}(val) => ::std::option::Option::Some(
                {% if field.is_length_delimited %}
                {%- if field.is_message %}
                {#- message field need to be cast the lifetime param #}
                F::{{ field.ident }}(unsafe { ::std::mem::transmute(val.as_ref()) })
                {%- else %} {#- if field.is_message #}
                F::{{ field.ident }}(val.as_ref())
                {%- endif %} {#- if field.is_message #}
                {% else %}
                F::{{ field.ident }}(val.clone())
                {% endif %}
            ),
            {%- endfor %}
        }
    }
    {%- endfor %}
}

impl<'bump> ::puroro::internal::de::DeserMessageFromBytesIter for {{ m.bumpalo_ident }}<'bump> {
    fn deser_field<I>(
        &mut self,
        field_number: i32,
        data: ::puroro::internal::types::FieldData<&mut ::puroro::internal::de::from_iter::ScopedIter<I>>,
    ) -> ::puroro::Result<()>
    where
        I: ::std::iter::Iterator<Item = ::std::io::Result<u8>>
    {
        use ::puroro::internal::impls::bumpalo::de::DeserFieldFromBytesIter;
        match field_number {
            {%- for field in m.fields %}
            {%- if !field.is_explicit_oneof_field %}
            {{ field.number }} => {
                {%- if field.has_optional_bit %}
                self._bitfield.set({{ field.bitfield_index }}, true);
                {%- endif %}
                {#- Temporaly disable #}
                todo!()
                {# DeserFieldFromBytesIter::<
                    {{ field.bumpalo_label_and_type_tags }}, BT
                >::deser_field(&mut self.{{ field.ident_unesc }}_mut(), data, &self._bump) #}
            }
            {%- endif %}
            {%- endfor %}

            {%- for oneof in m.oneofs %}
            {%- for field in oneof.fields %}
            {{ field.number }} => {
                use super::_puroro_nested::{{ m.submodule_ident }}::_puroro_private_oneofs::{{ oneof.bumpalo_enum_ident }} as E;
                if !matches!(
                    &self.{{ oneof.field_ident }},
                    E::{{ field.ident }}(_))
                {
                    self.{{ oneof.field_ident }} = E::{{ field.ident }}(
                        {%- if field.is_message %}
                        {#- need lifetime cast #}
                        todo!()
                        {#::puroro::BumpaloMessage::new_in(&self._bump)#}
                        {%- else %} {#- if field.is_message #}
                        ::puroro::internal::BumpDefault::default_in(&self._bump)
                        {%- endif %} {#- if field.is_message #}
                    );
                }
                let field_value_mut_ref = match &mut self.{{ oneof.field_ident }} {
                    E::{{ field.ident }}(v) => v,
                    _ => unreachable!(),
                };
                {#- temporaly disable #}
                todo!()
                {#- DeserFieldFromBytesIter::<
                    ::puroro::tags::OneofField, {{ field.bumpalo_field_type_tag }},
                >::deser_field(field_value_mut_ref, data, &self._bump)#}
            }
            {%- endfor %}
            {%- endfor %}

            _ => unimplemented!("TODO: This case should be handled properly..."),
        }
    }
}

impl<'bump> ::puroro::internal::se::SerMessageToIoWrite for {{ m.bumpalo_ident }}<'bump>
where
    Self: super::_puroro_traits::{{ m.ident }}Trait,
{%- for field in m.fields %}
{%- if field.is_message %}
    for<'a> <Self as super::_puroro_traits::{{ m.trait_ident }}>::Field{{ field.number }}MessageType<'a> :
        ::puroro::internal::se::SerMessageToIoWrite,
{%- endif %}
{%- endfor %}
{
    fn ser<W>(&self, out: &mut W) -> ::puroro::Result<()>
    where
        W: ::std::io::Write,
    {
        {%- for field in m.fields %}
        ::puroro::internal::se::SerFieldToIoWrite::<
            {{ field.trait_label_and_type_tags }}
        >::ser_field(
            {%- if field.is_repeated %}
            <Self as super::_puroro_traits::{{ m.ident }}Trait>::{{ field.ident }}(self),
            {%- else %}
            <Self as super::_puroro_traits::{{ m.ident }}Trait>::{{ field.ident_unesc }}_opt(self),
            {%- endif %}
            {{ field.number }},
            out
        )?;
        {%- endfor %} {#- for field in m.fields #}
        ::std::result::Result::Ok(())
    }
}
