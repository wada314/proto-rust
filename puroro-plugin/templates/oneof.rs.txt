
{#- Oneof union. Includes None case #}
{#- Neither Clone and Drop are implementable without the bitslice info. #}
pub union {{ ident_union }} {
    _none: (),
    {%- for field in fields %}
    {{ field.ident_union_item }}: {{ field.rust_field_type }},
    {%- endfor %} {#- for field in fields #}
}

{#- public oneof enum without contents, not including None case #}
#[repr(u32)]
#[derive(Debug, Clone, PartialEq)]
pub enum {{ ident_case }} {
    {%- for field in fields %}
    {{ field.ident_enum_item }},
    {%- endfor %} {#- for field in fields #}
}
{#- public oneof enum with ref to its contents, not including None case #}
#[repr(u32)]
#[derive(Debug, Clone, PartialEq)]
pub enum {{ ident_case_ref }} {%- if has_ld_type %}<'a>{%- endif %} {
    {%- for field in fields %}
    {{ field.ident_enum_item }}({{ field.rust_oneof_getter_type }}),
    {%- endfor %} {#- for field in fields #}
}

impl {{ ident_union }} {
    {%- for field in fields %}
    pub(crate) fn {{ field.ident_getter_opt }}<B: self::_puroro::bitvec::BitSlice>(&self, bits: &B) -> {{ field.rust_opt_getter_type }} {
        #[allow(unused)]
        use ::std::option::Option::{None, Some};
        use self::_puroro::internal::oneof_type::OneofCase;
        use self::_puroro::internal::oneof_field_type::OneofFieldType;

        let case_opt = self::{{ ident_case }}::from_bitslice(bits);
        if let Some(self::{{ ident_case }}::{{ field.ident_enum_item }}) = case_opt {
            let item = unsafe {
                &self.{{ field.ident_union_item }}
            };
            Some(item.get_field())
        } else {
            None
        }
    }
    {%- endfor %} {#- for field in fields #}
}

impl self::_puroro::internal::oneof_type::OneofUnion for {{ ident_union }} {
    type CaseRef<'a> = self::{{ ident_case_ref }}{% if has_ld_type %}<'a>{% endif %}
        where Self: 'a;

    fn case_ref<B: self::_puroro::bitvec::BitSlice>(&self, bits: &B)
        -> ::std::option::Option<Self::CaseRef<'_>>
    {
        use self::_puroro::internal::oneof_type::{OneofCase, OneofCaseRef};
        let case_opt = <{{ rust_case_type }} as OneofCase>::from_bitslice(bits);
        case_opt.map(|case| OneofCaseRef::from_union_and_case(self, case))
    }

    fn clear<B: self::_puroro::bitvec::BitSlice>(&mut self, bits: &mut B) {
        #[allow(unused)]
        use ::std::option::Option::Some;
        #[allow(unused)]
        use self::_puroro::internal::oneof_type::OneofCase;
        #[allow(unused)]
        use ::std::mem::ManuallyDrop;

        match self::{{ ident_case }}::from_bitslice(bits) {
            {%- for field in fields %}
            Some(self::{{ ident_case  }}::{{ field.ident_enum_item }}) => {
                unsafe { ManuallyDrop::take(&mut self.{{ field.ident_union_item }}) };
            }
            {%- endfor %} {#- for field in fields #}
            _ => (),
        }
        {#- Set the bitfield value to the last value + 1, which means None. #}
        bits.set_range({{ bitfield_start }}..{{ bitfield_end }}, {{ num_fields }});
    }

    fn clone<B: self::_puroro::bitvec::BitSlice>(&self, bits: &B) -> Self {
        #[allow(unused)]
        use ::std::option::Option::Some;
        #[allow(unused)]
        use self::_puroro::internal::oneof_type::OneofCase;
        #[allow(unused)]
        use ::std::clone::Clone;

        match self::{{ ident_case }}::from_bitslice(bits) {
            {%- for field in fields %}
            Some({{ ident_case  }}::{{ field.ident_enum_item }}) => {
                Self {
                    {{ field.ident_union_item }}: Clone::clone(unsafe { &self.{{ field.ident_union_item }} }),
                }
            }
            {%- endfor %} {#- for field in fields #}
            _ => Self {
                _none: (),
            },
        }
    }
}

impl ::std::default::Default for {{ ident_union }} {
    fn default() -> Self {
        Self { _none: () }
    }
}

impl self::_puroro::internal::oneof_type::OneofCase for {{ ident_case }} {
    const BITFIELD_BEGIN: usize = {{ bitfield_start }};
    const BITFIELD_END: usize = {{ bitfield_end }};
    fn from_u32(x: u32) -> Option<Self> {
        #[allow(unused)]
        use ::std::option::Option::{None, Some};
        match x {
            {%- for field in fields %}
            {{ field.index }} => Some(self::{{ ident_case }}::{{ field.ident_enum_item }}),
            {%- endfor %} {#- for field in fields #}
            _ => None,
        }
    }
}

impl<'a> self::_puroro::internal::oneof_type::OneofCaseRef<'a> for {{ ident_case_ref }} {%- if has_ld_type %}<'a>{%- endif %} {
    type Case = self::{{ ident_case }};
    type Union = self::{{ ident_union }};
    fn from_union_and_case(u: &'a Self::Union, case: Self::Case) -> Self {
        use self::_puroro::internal::oneof_field_type::OneofFieldType;
        match case {
            {%- for field in fields %}
            self::{{ ident_case }}::{{ field.ident_enum_item }} => 
                self::{{ ident_case_ref }}::{{ field.ident_enum_item }}(
                    unsafe { &u.{{ field.ident_union_item }} }.get_field()
                ),
            {%- endfor %} {#- for field in fields #}
        }
    }
}
