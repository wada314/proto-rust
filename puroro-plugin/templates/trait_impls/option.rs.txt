impl<T> {{ m.trait_ident }} for ::std::option::Option<T>
where
    T: {{ m.trait_ident }},
{
    {%- for f in m.fields %}
    {%- if f.is_message %}
    type Field{{ f.number }}MessageType<'this> where Self: 'this = T::Field{{ f.number }}MessageType<'this>;
    {%- endif %}

    {%- if f.is_repeated %}

    type Field{{ f.number }}RepeatedType<'this> where Self: 'this =
        ::puroro::internal::impls::option::OptionRepeatedField<T::Field{{ f.number }}RepeatedType<'this>>;
    fn {{ f.ident }}<'this>(&'this self) -> Self::Field{{ f.number }}RepeatedType<'this> {
        ::puroro::internal::impls::option::OptionRepeatedField::new(self.as_ref().map(|msg| msg.{{ f.ident }}()))
    }

    {%- else %} {#- if f.is_repeated #}

    {%- if !f.is_explicit_oneof_field %}
    fn {{ f.ident_unesc }}_opt<'this>(&'this self) -> ::std::option::Option<{{ f.trait_scalar_getter_type }}> {
        self.as_ref().and_then(|msg| msg.{{ f.ident_unesc }}_opt())
    }
    {%- endif %}

    {%- endif %} {#- if f.is_repeated #}
    {%- endfor %} {#- for f in m.fields #}

    {%- for oneof in m.oneofs %}
    fn {{ oneof.field_ident }}<'this>(&'this self) ->
        Option<
            super::_puroro_nested::{{ m.submodule_ident }}::_puroro_oneofs::{{ oneof.enum_ident }}
            {%- if oneof.has_ld_field %}
            {%- if oneof.has_message_field %}
            <'this, Self>
            {%- else %}
            <'this>
            {%- endif %}
            {%- endif %}
        >
    {
        use super::_puroro_nested::{{ m.submodule_ident }}::_puroro_oneofs::{{ oneof.enum_ident }} as E;
        self.as_ref().and_then(|msg| msg.{{ oneof.field_ident }}().map(|oneof| {
            match oneof {
                {%- for field in oneof.fields %}
                E::{{ field.ident }}(v) => E::{{ field.ident }}(v),
                {%- endfor %}
            }
        }))
    }
    {%- endfor %}
}