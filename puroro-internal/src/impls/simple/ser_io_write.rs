use std::convert::TryInto;

use crate::de::DoDefaultCheck;
use crate::se::to_io_write::write_field_number_and_wire_type;
use crate::se::{SerFieldToIoWrite, SerInternalDataToIoWrite};
use crate::{ErrorKind, FieldTypeGen, Result, SimpleImpl, StructInternalTypeGen};
use ::puroro::fixed_bits::{Bits32TypeTag, Bits64TypeTag};
use ::puroro::tags;
use ::puroro::types::WireType;
use ::puroro::variant::{Variant, VariantTypeTag};
use ::puroro::{GetImpl, SerToIoWrite};

use super::{LabelWrappedLdType, LabelWrappedMessageType, LabelWrappedType};

// Non-repeated, variant
type NonRepeatedVariant<X, V, _1, _2> = (tags::NonRepeated<_1, _2>, (X, tags::wire::Variant<V>));
type VariantNativeType<X, V> =
    <(X, tags::wire::Variant<V>) as tags::NumericalFieldTypeTag>::NativeType;
impl<X, V, _1, _2> SerFieldToIoWrite<NonRepeatedVariant<X, V, _1, _2>> for SimpleImpl
where
    NonRepeatedVariant<X, V, _1, _2>: DoDefaultCheck,
    // The type tag has corresponding Rust numerical type,
    (X, tags::wire::Variant<V>): tags::NumericalFieldTypeTag + VariantTypeTag,
    // ..and the type above can be wrapped by Option<> or Vec<> according to
    // the label (this is always true),
    VariantNativeType<X, V>: LabelWrappedType<tags::NonRepeated<_1, _2>> + Clone,
    // ..and the Rust type generated by FieldTypeGen is equal to the type above.
    Self: FieldTypeGen<
        NonRepeatedVariant<X, V, _1, _2>,
        Type = <VariantNativeType<X, V> as LabelWrappedType<tags::NonRepeated<_1, _2>>>::Type,
    >,
{
    fn ser_to_io_write<W>(
        field: &<Self as FieldTypeGen<NonRepeatedVariant<X, V, _1, _2>>>::Type,
        field_number: i32,
        out: &mut W,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        W: std::io::Write,
    {
        let do_default_check = <NonRepeatedVariant<X, V, _1, _2> as DoDefaultCheck>::VALUE;
        if let Some(value) =
            <VariantNativeType<X, V> as LabelWrappedType<tags::NonRepeated<_1, _2>>>::iter(field)
                .next()
        {
            let variant = Variant::from_native::<(X, tags::wire::Variant<V>)>(value.clone())?;
            if !do_default_check && !variant.is_zero() {
                write_field_number_and_wire_type(out, field_number, WireType::Variant)?;
                variant.encode_bytes(out)?;
            }
        }
        Ok(())
    }
}

// Repeated, variant
type RepeatedVariant<X, V> = (tags::Repeated, (X, tags::wire::Variant<V>));
impl<X, V> SerFieldToIoWrite<RepeatedVariant<X, V>> for SimpleImpl
where
    (X, tags::wire::Variant<V>): tags::NumericalFieldTypeTag + VariantTypeTag,
    VariantNativeType<X, V>: LabelWrappedType<tags::Repeated> + Clone,
    Self: FieldTypeGen<
        RepeatedVariant<X, V>,
        Type = <VariantNativeType<X, V> as LabelWrappedType<tags::Repeated>>::Type,
    >,
{
    fn ser_to_io_write<W>(
        field: &<Self as FieldTypeGen<RepeatedVariant<X, V>>>::Type,
        field_number: i32,
        out: &mut W,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        W: std::io::Write,
    {
        let mut iter =
            <VariantNativeType<X, V> as LabelWrappedType<tags::Repeated>>::iter(field).peekable();
        if iter.peek().is_some() {
            let mut buffer: Vec<u8> = Vec::new();
            for val in iter {
                let variant = Variant::from_native::<(X, tags::wire::Variant<V>)>(val.clone())?;
                variant.encode_bytes(&mut buffer)?;
            }
            let total_len: i32 = buffer
                .len()
                .try_into()
                .map_err(|_| ErrorKind::TooLongToSerialize)?;

            write_field_number_and_wire_type(out, field_number, WireType::LengthDelimited)?;
            Variant::from_i32(total_len)?.encode_bytes(out)?;
            out.write_all(&buffer)?;
        }
        Ok(())
    }
}

// Bits32
type Bits32NativeType<X, V> =
    <(X, tags::wire::Bits32<V>) as tags::NumericalFieldTypeTag>::NativeType;
type Bits32FieldTag<L, X, V> = (L, (X, tags::wire::Bits32<V>));
impl<L, X, V> SerFieldToIoWrite<Bits32FieldTag<L, X, V>> for SimpleImpl
where
    Bits32FieldTag<L, X, V>: DoDefaultCheck,
    (X, tags::wire::Bits32<V>): tags::NumericalFieldTypeTag + Bits32TypeTag,
    Bits32NativeType<X, V>: LabelWrappedType<L> + Clone,
    Self: FieldTypeGen<
        Bits32FieldTag<L, X, V>,
        Type = <Bits32NativeType<X, V> as LabelWrappedType<L>>::Type,
    >,
{
    fn ser_to_io_write<W>(
        field: &<Self as FieldTypeGen<Bits32FieldTag<L, X, V>>>::Type,
        field_number: i32,
        out: &mut W,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        W: std::io::Write,
    {
        let do_default_check = <Bits32FieldTag<L, X, V> as DoDefaultCheck>::VALUE;
        for item in <Bits32NativeType<X, V> as LabelWrappedType<L>>::iter(field) {
            if do_default_check
                && item.clone()
                    == <(X, tags::wire::Bits32<V>) as tags::NumericalFieldTypeTag>::default()
            {
                continue;
            }
            write_field_number_and_wire_type(out, field_number, WireType::Bits32)?;
            let bytes = <(X, tags::wire::Bits32<V>) as Bits32TypeTag>::into_array(item.clone());
            out.write_all(&bytes)?;
        }
        Ok(())
    }
}

// Bits64
type Bits64NativeType<X, V> =
    <(X, tags::wire::Bits64<V>) as tags::NumericalFieldTypeTag>::NativeType;
type Bits64FieldTag<L, X, V> = (L, (X, tags::wire::Bits64<V>));
impl<L, X, V> SerFieldToIoWrite<Bits64FieldTag<L, X, V>> for SimpleImpl
where
    Bits64FieldTag<L, X, V>: DoDefaultCheck,
    (X, tags::wire::Bits64<V>): tags::NumericalFieldTypeTag + Bits64TypeTag,
    Bits64NativeType<X, V>: LabelWrappedType<L> + Clone,
    Self: FieldTypeGen<
        Bits64FieldTag<L, X, V>,
        Type = <Bits64NativeType<X, V> as LabelWrappedType<L>>::Type,
    >,
{
    fn ser_to_io_write<W>(
        field: &<Self as FieldTypeGen<Bits64FieldTag<L, X, V>>>::Type,
        field_number: i32,
        out: &mut W,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        W: std::io::Write,
    {
        let do_default_check = <Bits64FieldTag<L, X, V> as DoDefaultCheck>::VALUE;
        for item in <Bits64NativeType<X, V> as LabelWrappedType<L>>::iter(field) {
            if do_default_check
                && item.clone()
                    == <(X, tags::wire::Bits64<V>) as tags::NumericalFieldTypeTag>::default()
            {
                continue;
            }
            write_field_number_and_wire_type(out, field_number, WireType::Bits64)?;
            let bytes = <(X, tags::wire::Bits64<V>) as Bits64TypeTag>::into_array(item.clone());
            out.write_all(&bytes)?;
        }
        Ok(())
    }
}

// Bytes
impl<L, X> SerFieldToIoWrite<(L, (X, tags::Bytes))> for SimpleImpl
where
    (L, (X, tags::Bytes)): DoDefaultCheck,
    [u8]: LabelWrappedLdType<L, X>,
    Self: FieldTypeGen<(L, (X, tags::Bytes)), Type = <[u8] as LabelWrappedLdType<L, X>>::Type>,
{
    fn ser_to_io_write<W>(
        field: &<Self as FieldTypeGen<(L, (X, tags::Bytes))>>::Type,
        field_number: i32,
        out: &mut W,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        W: std::io::Write,
    {
        let do_default_check = <(L, (X, tags::Bytes)) as DoDefaultCheck>::VALUE;
        for item in <[u8] as LabelWrappedLdType<L, X>>::iter(field) {
            if do_default_check && item.is_empty() {
                continue;
            }
            write_field_number_and_wire_type(out, field_number, WireType::LengthDelimited)?;
            let length: i32 = item
                .len()
                .try_into()
                .map_err(|_| ErrorKind::TooLongToSerialize)?;
            Variant::from_i32(length)?.encode_bytes(out)?;
            out.write_all(item)?;
        }
        Ok(())
    }
}

// Strings
impl<L, X> SerFieldToIoWrite<(L, (X, tags::String))> for SimpleImpl
where
    (L, (X, tags::String)): DoDefaultCheck,
    str: LabelWrappedLdType<L, X>,
    Self: FieldTypeGen<(L, (X, tags::String)), Type = <str as LabelWrappedLdType<L, X>>::Type>,
{
    fn ser_to_io_write<W>(
        field: &<Self as FieldTypeGen<(L, (X, tags::String))>>::Type,
        field_number: i32,
        out: &mut W,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        W: std::io::Write,
    {
        let do_default_check = <(L, (X, tags::String)) as DoDefaultCheck>::VALUE;
        for item in <str as LabelWrappedLdType<L, X>>::iter(field) {
            if do_default_check && item.is_empty() {
                continue;
            }
            write_field_number_and_wire_type(out, field_number, WireType::LengthDelimited)?;
            let length: i32 = item
                .len()
                .try_into()
                .map_err(|_| ErrorKind::TooLongToSerialize)?;
            Variant::from_i32(length)?.encode_bytes(out)?;
            out.write_all(item.as_bytes())?;
        }
        Ok(())
    }
}

// Message
type MessageFieldTag<L, X, M> = (L, (X, tags::Message<M>));
type ActualMessage<M> = <M as ::puroro::GetImpl<SimpleImpl>>::Type;
impl<L, X, M> SerFieldToIoWrite<MessageFieldTag<L, X, M>> for SimpleImpl
where
    M: GetImpl<SimpleImpl>,
    ActualMessage<M>: SerToIoWrite + LabelWrappedMessageType<L>,
    Self: FieldTypeGen<
        MessageFieldTag<L, X, M>,
        Type = <ActualMessage<M> as LabelWrappedMessageType<L>>::Type,
    >,
{
    fn ser_to_io_write<W>(
        field: &<Self as FieldTypeGen<MessageFieldTag<L, X, M>>>::Type,
        field_number: i32,
        out: &mut W,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        W: std::io::Write,
    {
        use std::ops::Deref as _;
        for boxed in <ActualMessage<M> as LabelWrappedMessageType<L>>::iter(field) {
            write_field_number_and_wire_type(out, field_number, WireType::LengthDelimited)?;
            let mut buffer: Vec<u8> = Vec::new();
            <ActualMessage<M> as SerToIoWrite>::ser(boxed.deref(), &mut buffer)?;
            let length: i32 = buffer
                .len()
                .try_into()
                .map_err(|_| ErrorKind::TooLongToSerialize)?;
            Variant::from_i32(length)?.encode_bytes(out)?;
            out.write_all(&buffer)?;
        }
        Ok(())
    }
}

impl SerInternalDataToIoWrite for SimpleImpl {
    fn ser_to_io_write<W>(
        _out: &mut W,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        W: std::io::Write,
    {
        Ok(())
    }
}
