use super::{LabelWrappedLdType, LabelWrappedType, SimpleImpl};
use crate::de::from_iter::{deser_from_scoped_iter, ScopedIter, Variants};
use crate::de::{DeserFieldFromBytesIter, DoDefaultCheck, MessageFromBytesIter};
use crate::{FieldTypeGen, StructInternalTypeGen};
use ::itertools::Itertools;
use ::puroro::fixed_bits::{Bits32TypeTag, Bits64TypeTag};
use ::puroro::types::FieldData;
use ::puroro::variant::VariantTypeTag;
use ::puroro::{tags, ErrorKind, GetImpl, Message, Result};
use ::std::collections::HashMap;

// deser from iterator

// deser from iterator, into variant type fields
type VariantNativeType<X, V> =
    <(X, tags::wire::Variant<V>) as tags::NumericalFieldTypeTag>::NativeType;
type VariantFieldTag<L, X, V> = (L, (X, tags::wire::Variant<V>));
impl<L, V, X> DeserFieldFromBytesIter<VariantFieldTag<L, X, V>> for SimpleImpl
where
    VariantFieldTag<L, X, V>: DoDefaultCheck,
    // The type tag has corresponding Rust numerical type,
    (X, tags::wire::Variant<V>): tags::NumericalFieldTypeTag + VariantTypeTag,
    // ..and the type above can be wrapped by Option<> or Vec<> according to
    // the label (this is always true),
    VariantNativeType<X, V>: LabelWrappedType<L>,
    // ..and the Rust type generated by FieldTypeGen is equal to the type above.
    Self: FieldTypeGen<
        VariantFieldTag<L, X, V>,
        Type = <VariantNativeType<X, V> as LabelWrappedType<L>>::Type,
    >,
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as FieldTypeGen<VariantFieldTag<L, X, V>>>::Type,
        data: FieldData<&mut ScopedIter<I>>,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        let do_default_check = <VariantFieldTag<L, X, V> as DoDefaultCheck>::VALUE;
        let default = <(X, tags::wire::Variant<V>) as tags::NumericalFieldTypeTag>::default;
        match data {
            FieldData::Variant(variant) => {
                let native = variant.to_native::<(X, tags::wire::Variant<V>)>()?;
                if !do_default_check || native != default() {
                    *LabelWrappedType::<L>::get_or_insert_with(field, default) = native;
                }
            }
            FieldData::LengthDelimited(iter) => {
                let variants_iter = Variants::new(iter);
                let values_iter = variants_iter
                    .map(|rv| rv.and_then(|v| v.to_native::<(X, tags::wire::Variant<V>)>()))
                    .filter_ok(|val| !do_default_check || val.clone() != default());
                LabelWrappedType::<L>::extend(field, values_iter)?;
            }
            FieldData::Bits32(_) | FieldData::Bits64(_) => Err(ErrorKind::UnexpectedWireType)?,
        };
        Ok(())
    }
}

// Bits32
type Bits32FieldTag<L, X, V> = (L, (X, tags::wire::Bits32<V>));
type Bits32NativeType<X, V> =
    <(X, tags::wire::Bits32<V>) as tags::NumericalFieldTypeTag>::NativeType;
impl<L, V, X> DeserFieldFromBytesIter<Bits32FieldTag<L, X, V>> for SimpleImpl
where
    Bits32FieldTag<L, X, V>: DoDefaultCheck,
    // The type tag has corresponding Rust numerical type,
    (X, tags::wire::Bits32<V>): tags::NumericalFieldTypeTag + Bits32TypeTag,
    // ..and the type above can be wrapped by Option<> or Vec<> according to
    // the label (this is always true),
    Bits32NativeType<X, V>: LabelWrappedType<L>,
    // ..and the Rust type generated by FieldTypeGen is equal to the type above.
    Self: FieldTypeGen<
        Bits32FieldTag<L, X, V>,
        Type = <Bits32NativeType<X, V> as LabelWrappedType<L>>::Type,
    >,
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as FieldTypeGen<Bits32FieldTag<L, X, V>>>::Type,
        data: FieldData<&mut ScopedIter<I>>,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        let do_default_check = <Bits32FieldTag<L, X, V> as DoDefaultCheck>::VALUE;
        let default = <(X, tags::wire::Bits32<V>) as tags::NumericalFieldTypeTag>::default;
        match data {
            FieldData::Bits32(bytes) => {
                let native = <(X, tags::wire::Bits32<V>) as Bits32TypeTag>::from_array(bytes);
                if !do_default_check || native != default() {
                    *LabelWrappedType::<L>::get_or_insert_with(field, default) = native;
                }
            }
            _ => Err(ErrorKind::UnexpectedWireType)?,
        };
        Ok(())
    }
}

// Bits64
type Bits64FieldTag<L, X, V> = (L, (X, tags::wire::Bits64<V>));
type Bits64NativeType<X, V> =
    <(X, tags::wire::Bits64<V>) as tags::NumericalFieldTypeTag>::NativeType;
impl<L, V, X> DeserFieldFromBytesIter<Bits64FieldTag<L, X, V>> for SimpleImpl
where
    Bits64FieldTag<L, X, V>: DoDefaultCheck,
    // The type tag has corresponding Rust numerical type,
    (X, tags::wire::Bits64<V>): tags::NumericalFieldTypeTag + Bits64TypeTag,
    // ..and the type above can be wrapped by Option<> or Vec<> according to
    // the label (this is always true),
    Bits64NativeType<X, V>: LabelWrappedType<L>,
    // ..and the Rust type generated by FieldTypeGen is equal to the type above.
    Self: FieldTypeGen<
        Bits64FieldTag<L, X, V>,
        Type = <Bits64NativeType<X, V> as LabelWrappedType<L>>::Type,
    >,
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as FieldTypeGen<Bits64FieldTag<L, X, V>>>::Type,
        data: FieldData<&mut ScopedIter<I>>,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        let do_default_check = <Bits64FieldTag<L, X, V> as DoDefaultCheck>::VALUE;
        let default = <(X, tags::wire::Bits64<V>) as tags::NumericalFieldTypeTag>::default;
        match data {
            FieldData::Bits64(bytes) => {
                let native = <(X, tags::wire::Bits64<V>) as Bits64TypeTag>::from_array(bytes);
                if !do_default_check || native != default() {
                    *LabelWrappedType::<L>::get_or_insert_with(field, default) = native;
                }
            }
            _ => Err(ErrorKind::UnexpectedWireType)?,
        };
        Ok(())
    }
}

// String
impl<L, X> DeserFieldFromBytesIter<(L, (X, tags::String))> for SimpleImpl
where
    (L, (X, tags::String)): DoDefaultCheck,
    str: LabelWrappedLdType<L, X>,
    Self: FieldTypeGen<(L, (X, tags::String)), Type = <str as LabelWrappedLdType<L, X>>::Type>,
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as FieldTypeGen<(L, (X, tags::String))>>::Type,
        data: FieldData<&mut ScopedIter<I>>,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        let do_default_check = <(L, (X, tags::String)) as DoDefaultCheck>::VALUE;
        match data {
            FieldData::LengthDelimited(iter) => {
                let string = String::from_utf8(iter.collect::<::std::io::Result<Vec<_>>>()?)
                    .map_err(|e| ErrorKind::InvalidUtf8(e))?;
                if !do_default_check || !string.is_empty() {
                    *<str as LabelWrappedLdType<L, X>>::get_or_insert_default(field) = string;
                }
            }
            _ => Err(ErrorKind::UnexpectedWireType)?,
        }
        Ok(())
    }
}

// Bytes
impl<L, X> DeserFieldFromBytesIter<(L, (X, tags::Bytes))> for SimpleImpl
where
    (L, (X, tags::Bytes)): DoDefaultCheck,
    [u8]: LabelWrappedLdType<L, X>,
    Self: FieldTypeGen<(L, (X, tags::Bytes)), Type = <[u8] as LabelWrappedLdType<L, X>>::Type>,
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as FieldTypeGen<(L, (X, tags::Bytes))>>::Type,
        data: FieldData<&mut ScopedIter<I>>,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        let do_default_check = <(L, (X, tags::Bytes)) as DoDefaultCheck>::VALUE;
        match data {
            FieldData::LengthDelimited(iter) => {
                let bytes = iter.collect::<::std::io::Result<Vec<_>>>()?;
                if !do_default_check || !bytes.is_empty() {
                    *<[u8] as LabelWrappedLdType<L, X>>::get_or_insert_default(field) = bytes;
                }
            }
            _ => Err(ErrorKind::UnexpectedWireType)?,
        }
        Ok(())
    }
}

// Message
impl<X, M, _1, _2> DeserFieldFromBytesIter<(tags::NonRepeated<_1, _2>, (X, tags::Message<M>))>
    for SimpleImpl
where
    M: GetImpl<SimpleImpl>,
    <M as GetImpl<SimpleImpl>>::Type: Message + MessageFromBytesIter + Default,
    Self: FieldTypeGen<
        (tags::NonRepeated<_1, _2>, (X, tags::Message<M>)),
        Type = Option<Box<<M as GetImpl<SimpleImpl>>::Type>>,
    >,
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as FieldTypeGen<(tags::NonRepeated<_1, _2>, (X, tags::Message<M>))>>::Type,
        data: FieldData<&mut ScopedIter<I>>,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        use ::std::ops::DerefMut;
        match data {
            FieldData::LengthDelimited(iter) => deser_from_scoped_iter(
                field
                    .get_or_insert_with(|| Box::new(Default::default()))
                    .deref_mut(),
                iter,
            ),
            _ => Err(ErrorKind::UnexpectedWireType)?,
        }
    }
}

impl<X, M> DeserFieldFromBytesIter<(tags::Repeated, (X, tags::Message<M>))> for SimpleImpl
where
    M: GetImpl<SimpleImpl>,
    <M as GetImpl<SimpleImpl>>::Type: Message + MessageFromBytesIter + Default,
    Self: FieldTypeGen<
        (tags::Repeated, (X, tags::Message<M>)),
        Type = Vec<<M as GetImpl<SimpleImpl>>::Type>,
    >,
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as FieldTypeGen<(tags::Repeated, (X, tags::Message<M>))>>::Type,
        data: FieldData<&mut ScopedIter<I>>,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        match data {
            FieldData::LengthDelimited(iter) => {
                field.push(Default::default());
                deser_from_scoped_iter(field.last_mut().unwrap(), iter)
            }
            _ => Err(ErrorKind::UnexpectedWireType)?,
        }
    }
}

// Map

use super::type_gen::{GetVecItemType, VecItemType};
impl<X, K, V> DeserFieldFromBytesIter<tags::Map<X, K, V>> for SimpleImpl
where
    Self: FieldTypeGen<tags::Map<X, K, V>, Type = HashMap<VecItemType<X, K>, VecItemType<X, V>>>,
    Self: FieldTypeGen<(tags::Repeated, (X, K))>,
    Self: FieldTypeGen<(tags::Repeated, (X, V))>,
    <Self as FieldTypeGen<(tags::Repeated, (X, K))>>::Type: GetVecItemType,
    <Self as FieldTypeGen<(tags::Repeated, (X, V))>>::Type: GetVecItemType,
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as FieldTypeGen<tags::Map<X, K, V>>>::Type,
        data: FieldData<&mut ScopedIter<I>>,
        _internal_data: &<Self as StructInternalTypeGen>::Type,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        todo!()
    }
}
