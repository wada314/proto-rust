mod type_gen;

use ::std::borrow::Cow;

use puroro::variant;
use puroro::{tags, DeserFieldFromBytesIter, Result, StructInternalTypeGen};

pub struct SimpleImpl;
impl tags::ImplTypeTag for SimpleImpl {}

// Struct's internal type generator

impl StructInternalTypeGen for SimpleImpl {
    // TODO
    type Type = ();
}

// deser from iterator
// deser from iterator, into variant type fields
impl<L, V, S> DeserFieldFromBytesIter<(L, (S, tags::wire::Variant<V>))> for SimpleImpl
where
    // The type tag has corresponding Rust numerical type,
    (S, tags::wire::Variant<V>): tags::NumericalFieldTypeTag + variant::VariantTypeTag,
    // ..and the type above can be wrapped by Option<> or Vec<> according to
    // the label (this is always true),
    <(S, tags::wire::Variant<V>) as tags::NumericalFieldTypeTag>::NativeType: LabelWrappedType<L>,
    // ..and the Rust type generated by FieldTypeGen is equal to the type above.
    Self: puroro::FieldTypeGen<(L, (S, tags::wire::Variant<V>)), Type =
        <<(S, tags::wire::Variant<V>) as tags::NumericalFieldTypeTag>::NativeType as LabelWrappedType<L>>::Type>
{
    fn deser_from_scoped_bytes_iter<I>(
        field: &mut <Self as puroro::FieldTypeGen<(L, (S, tags::wire::Variant<V>))>>::Type,
        data: puroro::FieldData<&mut puroro::de::from_iter::ScopedIter<I>>,
    ) -> Result<()>
    where
        I: Iterator<Item = std::io::Result<u8>>,
    {
        match data {
            puroro::FieldData::Variant(variant) => {
                // todo: proto3 default value check
                let native = variant.to_native::<(S, tags::wire::Variant<V>)>()?;
                *LabelWrappedType::<L>::get_or_insert_with(
                    field,
                    <(S, tags::wire::Variant<V>) as tags::NumericalFieldTypeTag>::default
                ) = native;
            },
            puroro::FieldData::LengthDelimited(_) => todo!(),
            puroro::FieldData::Bits32(_) => todo!(),
            puroro::FieldData::Bits64(_) => todo!(),
        };
        Ok(())
    }
}

// Utilities

/// A utility type-function which returns a type wrapped by `Option` or `Vec` according
/// to the label (e.g. `optional` => `Option`).
/// Can be applied for every types except length delimited types (String, Bytes, Message).
/// - `optional` => `Option<T>`
/// - `required` => `Option<T>` // Needs revisit!!
/// - (unlabeled) => `T`
/// - `repeated` => `Vec<T>`
pub trait LabelWrappedType<L> {
    type Type;
    fn get_or_insert_with<F>(wrapped: &mut Self::Type, f: F) -> &mut Self
    where
        F: FnOnce() -> Self;
}
impl<T> LabelWrappedType<tags::Required> for T {
    // TODO: Revisit... T or Option<T>
    type Type = Option<T>;
    fn get_or_insert_with<F>(wrapped: &mut Self::Type, f: F) -> &mut Self
    where
        F: FnOnce() -> Self,
    {
        wrapped.get_or_insert_with(f)
    }
}
impl<T> LabelWrappedType<tags::Optional> for T {
    type Type = Option<T>;
    fn get_or_insert_with<F>(wrapped: &mut Self::Type, f: F) -> &mut Self
    where
        F: FnOnce() -> Self,
    {
        wrapped.get_or_insert_with(f)
    }
}
impl<T> LabelWrappedType<tags::Unlabeled> for T {
    type Type = T;
    fn get_or_insert_with<F>(wrapped: &mut Self::Type, f: F) -> &mut Self
    where
        F: FnOnce() -> Self,
    {
        wrapped
    }
}
impl<T> LabelWrappedType<tags::Repeated> for T {
    type Type = Vec<T>;

    fn get_or_insert_with<F>(wrapped: &mut Self::Type, f: F) -> &mut Self
    where
        F: FnOnce() -> Self,
    {
        wrapped.push((f)());
        wrapped.last_mut().unwrap()
    }
}

/// A custom version of `LabelWrappedType` for String and Bytes.
///
/// - proto2:
///   - `optional` => `Option<Cow<'static, T>>`
///   - `required` => `Option<Cow<'static, T>>` // Needs revisit!!
///   - `repeated` => `Vec<T>`
/// - proto3:
///   - (unlabeled) => `T`
///   - `optional` => `Option<T>`
///   - `repeated` => `Vec<T>`
pub trait LabelWrappedLDType<L, X>: ToOwned
where
    <Self as ToOwned>::Owned: Default,
{
    type Type;
    fn get_or_insert_default(wrapped: &mut Self::Type) -> &mut <Self as ToOwned>::Owned;
}
impl<T> LabelWrappedLDType<tags::Required, tags::Proto2> for T
where
    T: ToOwned + 'static,
    <T as ToOwned>::Owned: Default,
{
    type Type = Option<Cow<'static, T>>;
    fn get_or_insert_default(wrapped: &mut Self::Type) -> &mut <Self as ToOwned>::Owned {
        wrapped
            .get_or_insert_with(|| Cow::Owned(Default::default()))
            .to_mut()
    }
}
impl<T> LabelWrappedLDType<tags::Optional, tags::Proto2> for T
where
    T: ToOwned + 'static,
    <T as ToOwned>::Owned: Default,
{
    type Type = Option<Cow<'static, T>>;
    fn get_or_insert_default(wrapped: &mut Self::Type) -> &mut <Self as ToOwned>::Owned {
        wrapped
            .get_or_insert_with(|| Cow::Owned(Default::default()))
            .to_mut()
    }
}
impl<T> LabelWrappedLDType<tags::Unlabeled, tags::Proto3> for T
where
    T: ToOwned + 'static,
    <T as ToOwned>::Owned: Default,
{
    type Type = <T as ToOwned>::Owned;
    fn get_or_insert_default(wrapped: &mut Self::Type) -> &mut <Self as ToOwned>::Owned {
        wrapped
    }
}
impl<T> LabelWrappedLDType<tags::Optional, tags::Proto3> for T
where
    T: ToOwned + 'static,
    <T as ToOwned>::Owned: Default,
{
    type Type = Option<<T as ToOwned>::Owned>;
    fn get_or_insert_default(wrapped: &mut Self::Type) -> &mut <Self as ToOwned>::Owned {
        wrapped.get_or_insert_with(Default::default)
    }
}
impl<T, X> LabelWrappedLDType<tags::Repeated, X> for T
where
    T: ToOwned + 'static,
    <T as ToOwned>::Owned: Default,
{
    type Type = Vec<<T as ToOwned>::Owned>;
    fn get_or_insert_default(wrapped: &mut Self::Type) -> &mut <Self as ToOwned>::Owned {
        wrapped.push(Default::default());
        wrapped.last_mut().unwrap()
    }
}
